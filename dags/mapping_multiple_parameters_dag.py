from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.operators.bash import BashOperator
from airflow.decorators import task
from datetime import datetime

with DAG(
    dag_id="mapping_multiple_parameters_dag",
    start_date=datetime(2022,7,1),
    schedule_interval=None,
    catchup=False
) as dag:

    ### mapping over 2 kwargs - cross product

    cross_product_example = BashOperator.partial(
    task_id="cross_product_example"
    ).expand(
        bash_command=[
            "echo $WORD", # prints the env variable WORD
            "echo `expr length $WORD`", # prints the number of letters in WORD
            "echo ${WORD//e/X}" # replaces each "e" in WORD with "X"
        ],
        env=[
            {"WORD": "hello"},
            {"WORD": "tea"},
            {"WORD": "goodbye"}
        ]
    )

    # results in 3x3=9 mapped task instances printing:
    # hello, tea, goodbye, 5, 3, 7, hXllo, tXa, goodbyX



    ### mapping over sets of keyword arguments
    """
    # input sets of kwargs directly as a list[dict] PENDING IMPLEMENTATION!
    t1 = BashOperator.partial(task_id="expand_kwargs_direct").expand_kwargs(
        [
            {"bash_command": "echo $WORD", "env" : {"WORD": "hello"}},
            {
                "bash_command": "echo `expr length $WORD`",
                "env" : {"WORD": "tea"}
            },
            {"bash_command": "echo ${WORD//e/X}", "env" : {"WORD": "goodbye"}}
        ]
    )
    """

    # input sets of kwargs generated by another task as an XComArg object
    @task
    def turn_into_XComArg():
        return [
            {"bash_command": "echo $WORD", "env" : {"WORD": "hello"}},
            {
                "bash_command": "echo `expr length $WORD`",
                "env" : {"WORD": "tea"}
            },
            {"bash_command": "echo ${WORD//e/X}", "env" : {"WORD": "goodbye"}}
        ]

    kwargs = turn_into_XComArg()

    t2 = BashOperator.partial(
        task_id="expand_kwargs_XComArg"
    ).expand_kwargs(kwargs)


    # results in 3 mapped instances each, printing:
    # hello, 3, goodbyX



    ### mapping over a list containing a zip

    # use the zip function to create three-tuples out of three lists
    zipped_arguments = list(zip([1,2,3], [10,20,30], [100,200,300]))
    # zipped_arguments contains: [(1,10,100), (2,20,200), (3,30,300)]


    # creating the mapped task instances using the TaskFlowAPI
    @task
    def TaskFlow_add_numbers(zipped_x_y_z):
        print(zipped_x_y_z)
        return zipped_x_y_z[0] + zipped_x_y_z[1] + zipped_x_y_z[2]

    TaskFlow_add_numbers.expand(zipped_x_y_z=zipped_arguments)


    # creating the mapped task instances using the PythonOperator
    def add_numbers(x,y,z):
        # the op_args keyword of the PythonOperator performs the unpacking of
        # the list that was provided
        return x+y+z

    standard_add_numbers = PythonOperator.partial(
        task_id="standard_add_numbers",
        python_callable=add_numbers
    ).expand(op_args=zipped_arguments)


    # results in 3 mapped instances each, printing:
    # 111, 222, 333